import{_ as h,C as p,c as o,o as d,j as e,G as s,a4 as t,a as g}from"./chunks/framework.Db__vQwl.js";const c="/assets/image-20240901173123251.Cu9qoRUQ.png",k="/assets/image-20240901174146022.Bbs-8_ct.png",m="/assets/image-20240901174303362.u66QY5Ko.png",u="/assets/image-20240901174546501.CQlRaDdR.png",F="/assets/image-20240901204231914.Kmvn0k8P.png",b="/assets/image-20240901204524392.yl0ABH0h.png",y="/assets/image-20240901204854694.D4Ylelvs.png",_="/assets/image-20240901204835698.PISlyd0v.png",n="/assets/image-20240901220004344.CNFfBXDi.png",f="/assets/image-20240901205255026.D5uaKuhD.png",C="/assets/image-20240901205404973.CpyLKiei.png",B="/assets/image-20240901205625518.DmPUoCY0.png",q="/assets/image-20240901210012461.DZYoTL6J.png",E="/assets/image-20240901210221923.D2FAvNNt.png",x="/assets/image-20240901210459960.Cg1zFxP5.png",v="/assets/image-20240901212048354.bZVrFDcE.png",P="/assets/image-20240901212808965.D20KVBcs.png",z="/assets/image-20240901213058850.DqWIhQFy.png",A="/assets/image-20240901213258580.R5CqKipZ.png",D="/assets/image-20240901213416201.B_Mnpoa6.png",w="/assets/image-20240901213850527.DC6E8eFK.png",L="/assets/image-20240901214050024.bNv13HTO.png",G="/assets/image-20240901214208932.Cx8u-jh3.png",T="/assets/image-20240901214256707.DSX65tui.png",R="/assets/image-20240901214412233.CnmqkzcP.png",S="/assets/image-20240901215238584.BT-Pmrz5.png",W="/assets/image-20240901215305627.xyK7Fte9.png",I="/assets/image-20240901215409226.DQFt6ru8.png",M="/assets/image-20240901215447160.DANiEpAG.png",V="/assets/image-20240901215526560.DxLqayHS.png",N="/assets/image-20240901215751326.Dq_oPjLj.png",U="/assets/image-20240901220431059.DGiKUgKO.png",j="/assets/image-20240901220542401.CU3oWnyx.png",K="/assets/image-20240901221155737.wYdHVVmu.png",$="/assets/image-20240901221235802.Cu359qa8.png",Q="/assets/image-20240901221345791.DIbbXaNh.png",Y="/assets/image-20240901221530299.DzUT8oN9.png",l="/assets/image-20240901224103951.Bc3aRKIm.png",r="/assets/image-20240901224715756.BpFgGQmW.png",H="/assets/image-20240901221944015.Bg-QJlJ5.png",J="/assets/image-20240901222501572.CJpjZ5kg.png",Z="/assets/image-20240901222722684.DYbcmYZv.png",O="/assets/image-20240901223006395.nhWXJWiF.png",X="/assets/image-20240901223242809.BvnFdU7j.png",aa="/assets/image-20240901224245577.Bj_el9f4.png",ia="/assets/image-20240901225415765.BovEt645.png",sa="/assets/image-20240901225450107.BgWdQMyj.png",ta="/assets/image-20240901225559749.CHnbpb5c.png",ea="/assets/image-20240901225659741.DYwkavEg.png",na="/assets/image-20240901225844943.CPjEQQaK.png",la="/assets/image-20240905160429304.DvQVNsjw.png",ra="/assets/image-20240902144827481.C-wfuNF-.png",ha="/assets/image-20250328144417642.Dcbm2G3S.png",pa="/assets/6b269586bad5be3cd5f45d26469744f2.CXkjwMRk.png",oa="/assets/f9a5b805dbe78e0e0287710aaffffa85.CEBL2Vnw.png",da="/assets/945dfee8ec9bd4cf673b4b71a5935e07.CeIuJCuO.png",ga="/assets/97837c0142d0806287fb9d0510e8fc60.C_WNr1bU.png",ca="/assets/ae2e9ae9e20dfaccf229292a2d0a6374.Bi82ujcS.png",ka="/assets/729a9ed9919254539a425b576fa34fca.BGjarMKw.png",ma="/assets/b07df83652cfce93b430a6790a55211d.CgZWUpgB.png",ua="/assets/eb036d304d29d87b349665b6e6ae0fd6.CFeDL_Iz.png",Fa="/assets/e5a1974417b6d8bf8946b10dd0663989.B2CfMGeM.png",ba="/assets/6f4266c9d90f4a7384d37ac2ecb72a6b.CeMbQ8Qk.png",ya="/assets/3f4744293d21487fafa15085ef739014.FbrrUxOt.png",_a="/assets/3d7adf92d9161f64a4c312d95ac75791.DP7uKxA0.png",fa="/assets/46e31f667a410c38afaa59c01c9e1010.D9pTolb5.png",Ca="/assets/b9e226190af71da58794ed2c840345df.DlvtWmEq.png",Ba="/assets/4c511a3dbaae9bbf4f703dd932dfa716.BKxkPl_4.png",qa="/assets/4f465fcaf70b9ac116445d48e76e0a41.02rPlcEP.png",Ea="/assets/f500186331ba8f16f01396d0f053f3aa.DU41Xyfo.png",xa="/assets/7e66408ab8b8a5f024d48e78e4cfe8ed.Dcq-LLcu.png",va="/assets/2a770898c9305c51942d616548ba22af.D1jxskT5.png",Pa="/assets/7542cf48636341aa65fab274b083d0c4.BwgeoDvr.png",za="/assets/ed482fdacf04ef9e19811c42423c6188.DhI3DMTe.png",Aa="/assets/434e60edfe327a1959c5340caf024dc5.Do4zFKYc.png",Da="/assets/732ec20905080362fb7422a200ebc299.esVOgeej.png",wa="/assets/4a9f97d7043677c2e429e52c8f6b7f3b.BETuVNCy.png",La="/assets/d202e1913673b54596d3314e614a38b0.2JFBwTbn.png",Ga="/assets/c3c2ab9bd695808b791f61877b2e8970.BFamuuGC.png",Ta="/assets/4acfd58a84e9c2820c9aa3084590a298.DUYyMZiD.png",Ra="/assets/665b1421915d51e9d077c259cf0efd92.WfYsYlaC.png",Sa="/assets/7ba060eee7bc1e1f49f547b01d7f44db.CrQp_bdU.png",Wa="/assets/ea7a63615c0742a809fb8442b4b14d86.BDyuCTA-.png",Ia="/assets/259a5847cd9a99d591a6ff74662b2de9.Bu0jKwoW.png",Ma="/assets/80e8b3ac99bc783564b62c2edac684c5.DFBpcG11.png",Va="/assets/63a44ca6cf82eec92012504aad5e5def.cqGr0G8h.png",Na="/assets/2b3a265250bbe207f4805346354c413f.B3M97LrQ.png",Ua="/assets/ca71e8b235577726ebf737e250e7d89a.ZoWNq7bD.png",ja="/assets/dec96b9c0d22ce8ef00603bfa4eeeb17.BRYt3mFm.png",Ka="/assets/23ec4c347d16b19ac41a2bf9e49a4027.CrP3lVNr.png",$a="/assets/c7d0944271c7df1808d539d594b8ff53.D-OFWemb.png",ii=JSON.parse('{"title":"Git-Learning","description":"","frontmatter":{},"headers":[],"relativePath":"Git学习笔记/Git-Learning-Local.md","filePath":"Git学习笔记/Git-Learning-Local.md","lastUpdated":1744204135000}'),Qa={name:"Git学习笔记/Git-Learning-Local.md"};function Ya(Ha,a,Ja,Za,Oa,Xa){const i=p("ArticleMetadata");return d(),o("div",null,[a[0]||(a[0]=e("h1",{id:"git-learning",tabindex:"-1"},[g("Git-Learning "),e("a",{class:"header-anchor",href:"#git-learning","aria-label":'Permalink to "Git-Learning"'},"​")],-1)),s(i),a[1]||(a[1]=t('<h2 id="一、基本概念" tabindex="-1">一、基本概念 <a class="header-anchor" href="#一、基本概念" aria-label="Permalink to &quot;一、基本概念&quot;">​</a></h2><h3 id="_1、git全局设置-配置用户信息" tabindex="-1">1、Git全局设置-配置用户信息 <a class="header-anchor" href="#_1、git全局设置-配置用户信息" aria-label="Permalink to &quot;1、Git全局设置-配置用户信息&quot;">​</a></h3><p><img src="'+c+'" alt="image-20240901173123251" loading="lazy"></p><h3 id="_2、获取git仓库-本地初始化" tabindex="-1">2、获取Git仓库-本地初始化 <a class="header-anchor" href="#_2、获取git仓库-本地初始化" aria-label="Permalink to &quot;2、获取Git仓库-本地初始化&quot;">​</a></h3><p><img src="'+k+'" alt="image-20240901174146022" loading="lazy"></p><h3 id="_3、获取git仓库-从远程仓库克隆" tabindex="-1">3、获取Git仓库-从远程仓库克隆 <a class="header-anchor" href="#_3、获取git仓库-从远程仓库克隆" aria-label="Permalink to &quot;3、获取Git仓库-从远程仓库克隆&quot;">​</a></h3><p><img src="'+m+'" alt="image-20240901174303362" loading="lazy"></p><h3 id="_4、工作区、暂存区、版本库的概念" tabindex="-1">4、<mark>工作区、暂存区、版本库</mark>的概念 <a class="header-anchor" href="#_4、工作区、暂存区、版本库的概念" aria-label="Permalink to &quot;4、==工作区、暂存区、版本库==的概念&quot;">​</a></h3><p><img src="'+u+'" alt="image-20240901174546501" loading="lazy"></p><h3 id="_5、git工作区中文件的状态" tabindex="-1">5、Git工作区中文件的<mark>状态</mark> <a class="header-anchor" href="#_5、git工作区中文件的状态" aria-label="Permalink to &quot;5、Git工作区中文件的==状态==&quot;">​</a></h3><p><img src="'+F+'" alt="image-20240901204231914" loading="lazy"></p><h2 id="二、本地仓库操作" tabindex="-1">二、本地仓库操作 <a class="header-anchor" href="#二、本地仓库操作" aria-label="Permalink to &quot;二、本地仓库操作&quot;">​</a></h2><p><img src="'+b+'" alt="image-20240901204524392" loading="lazy"></p><h3 id="_1、git-reset-取消暂存或切换版本" tabindex="-1">1、git reset-取消暂存或切换版本 <a class="header-anchor" href="#_1、git-reset-取消暂存或切换版本" aria-label="Permalink to &quot;1、git reset-取消暂存或切换版本&quot;">​</a></h3><p><img src="'+y+'" alt="image-20240901204854694" loading="lazy"></p><h3 id="_2、git-commit-提交" tabindex="-1">2、git commit-提交 <a class="header-anchor" href="#_2、git-commit-提交" aria-label="Permalink to &quot;2、git commit-提交&quot;">​</a></h3><p><img src="'+_+'" alt="image-20240901204835698" loading="lazy"></p><p><mark><strong>注意</strong></mark>：<strong>git commit -m &#39;&#39;test&#39;&#39; b1.txt <mark>-i</mark></strong></p><p><img src="'+n+'" alt="image-20240901220004344" loading="lazy"></p><h3 id="_3、git-log-查看日志" tabindex="-1">3、git log-查看日志 <a class="header-anchor" href="#_3、git-log-查看日志" aria-label="Permalink to &quot;3、git log-查看日志&quot;">​</a></h3><p><img src="'+f+'" alt="image-20240901205255026" loading="lazy"></p><h2 id="三、远程仓库操作命令" tabindex="-1">三、<mark>远程仓库操作</mark>命令 <a class="header-anchor" href="#三、远程仓库操作命令" aria-label="Permalink to &quot;三、==远程仓库操作==命令&quot;">​</a></h2><p><img src="'+C+'" alt="image-20240901205404973" loading="lazy"></p><h3 id="_1、git-remote-查看远程仓库" tabindex="-1">1、git remote-查看远程仓库 <a class="header-anchor" href="#_1、git-remote-查看远程仓库" aria-label="Permalink to &quot;1、git remote-查看远程仓库&quot;">​</a></h3><p><img src="'+B+'" alt="image-20240901205625518" loading="lazy"></p><h3 id="_2、git-remote-add-shortname-url" tabindex="-1">2、git <mark>remote add</mark> <code>&lt; shortname&gt;</code> <code>&lt; url&gt;</code> <a class="header-anchor" href="#_2、git-remote-add-shortname-url" aria-label="Permalink to &quot;2、git ==remote add== `&lt; shortname&gt;` `&lt; url&gt;`&quot;">​</a></h3><p><img src="'+q+'" alt="image-20240901210012461" loading="lazy"></p><h3 id="_3、git-clone-url" tabindex="-1">3、git clone [url] <a class="header-anchor" href="#_3、git-clone-url" aria-label="Permalink to &quot;3、git clone [url]&quot;">​</a></h3><p><img src="'+E+'" alt="image-20240901210221923" loading="lazy"></p><h3 id="_4、-git-push-remote-name-branch-name" tabindex="-1">4、 git <mark>push</mark> [remote-name] [branch-name] <a class="header-anchor" href="#_4、-git-push-remote-name-branch-name" aria-label="Permalink to &quot;4、 git ==push== [remote-name] [branch-name]&quot;">​</a></h3><p><strong><mark>remote-name</mark>为使用git remote add <code>&lt;shortname&gt;</code> <code>&lt;url&gt;</code>添加远程仓库时指定的<mark>仓库别名</mark>shortname；当该项目是从远程仓库直接clone过来时，<mark>默认</mark>的remote-name为<mark>origin</mark></strong></p><p><img src="'+x+'" alt="image-20240901210459960" loading="lazy"></p><h3 id="_5、git-pull-short-name-branch-name" tabindex="-1">5、git <mark>pull</mark> [short-name] [branch-name] <a class="header-anchor" href="#_5、git-pull-short-name-branch-name" aria-label="Permalink to &quot;5、git ==pull== [short-name] [branch-name]&quot;">​</a></h3><p><img src="'+v+'" alt="image-20240901212048354" loading="lazy"></p><h2 id="四、分支操作" tabindex="-1">四、<mark>分支操作</mark> <a class="header-anchor" href="#四、分支操作" aria-label="Permalink to &quot;四、==分支操作==&quot;">​</a></h2><p><img src="'+P+'" alt="image-20240901212808965" loading="lazy"></p><h3 id="_1、git-branch-查看分支" tabindex="-1">1、git branch-查看分支 <a class="header-anchor" href="#_1、git-branch-查看分支" aria-label="Permalink to &quot;1、git branch-查看分支&quot;">​</a></h3><p><img src="'+z+'" alt="image-20240901213058850" loading="lazy"></p><h3 id="_2、git-branch-branch-name-创建分支" tabindex="-1">2、git branch [branch-name]-创建分支 <a class="header-anchor" href="#_2、git-branch-branch-name-创建分支" aria-label="Permalink to &quot;2、git branch [branch-name]-创建分支&quot;">​</a></h3><p><img src="'+A+'" alt="image-20240901213258580" loading="lazy"></p><h3 id="_3、git-checkout-branch-name-切换分支" tabindex="-1">3、git checkout [branch-name]-切换分支 <a class="header-anchor" href="#_3、git-checkout-branch-name-切换分支" aria-label="Permalink to &quot;3、git checkout [branch-name]-切换分支&quot;">​</a></h3><p><img src="'+D+'" alt="image-20240901213416201" loading="lazy"></p><h3 id="_4、git-push-short-name-branch-name-推送值远程仓库分支" tabindex="-1">4、git push [short-name] [branch-name]-推送值远程仓库分支 <a class="header-anchor" href="#_4、git-push-short-name-branch-name-推送值远程仓库分支" aria-label="Permalink to &quot;4、git push [short-name] [branch-name]-推送值远程仓库分支&quot;">​</a></h3><p><img src="'+w+'" alt="image-20240901213850527" loading="lazy"></p><h3 id="_5、git-merge-name-合并分支" tabindex="-1">5、git <mark>merge</mark> [name] -合并分支 <a class="header-anchor" href="#_5、git-merge-name-合并分支" aria-label="Permalink to &quot;5、git ==merge== [name] -合并分支&quot;">​</a></h3><p><img src="'+L+'" alt="image-20240901214050024" loading="lazy"></p><p><strong>①出现该窗口：</strong></p><p><img src="'+G+'" alt="image-20240901214208932" loading="lazy"></p><p><strong>②按下 <mark>i</mark> 输入备注信息：</strong></p><p><img src="'+T+'" alt="image-20240901214256707" loading="lazy"></p><p><strong>③按下<mark>esc</mark>，再输入==:wq==(保存退出)：</strong></p><p><img src="'+R+'" alt="image-20240901214412233" loading="lazy"></p><h3 id="_6、合并分支常见错误-同时对同一个文件都修改" tabindex="-1">6、<mark>合并分支常见错误</mark>-同时对同一个文件都修改 <a class="header-anchor" href="#_6、合并分支常见错误-同时对同一个文件都修改" aria-label="Permalink to &quot;6、==合并分支常见错误==-同时对同一个文件都修改&quot;">​</a></h3><p><img src="'+S+'" alt="image-20240901215238584" loading="lazy"><img src="'+W+'" alt="image-20240901215305627" loading="lazy"></p><p><img src="'+I+'" alt="image-20240901215409226" loading="lazy"></p><p><img src="'+M+'" alt="image-20240901215447160" loading="lazy"></p><p><img src="'+V+'" alt="image-20240901215526560" loading="lazy"></p><p><img src="'+N+'" alt="image-20240901215751326" loading="lazy"></p><p><img src="'+n+'" alt="image-20240901220004344" loading="lazy"></p><h2 id="五、标签操作" tabindex="-1">五、标签操作 <a class="header-anchor" href="#五、标签操作" aria-label="Permalink to &quot;五、标签操作&quot;">​</a></h2><ul><li><strong>标签是静态的，可以理解为当前分支的一个特定状态，一旦确定了该标签就不可修改了</strong>，</li><li><strong>而分支是动态的，分支可以不断更新并保存</strong></li></ul><p><img src="'+U+'" alt="image-20240901220431059" loading="lazy"></p><p><img src="'+j+'" alt="image-20240901220542401" loading="lazy"></p><h3 id="_1、git-tag-查看标签" tabindex="-1">1、git tag-查看标签 <a class="header-anchor" href="#_1、git-tag-查看标签" aria-label="Permalink to &quot;1、git tag-查看标签&quot;">​</a></h3><p><img src="'+K+'" alt="image-20240901221155737" loading="lazy"></p><h3 id="_2、git-tag-tag-name-创建标签" tabindex="-1">2、git tag [tag-name] -创建标签 <a class="header-anchor" href="#_2、git-tag-tag-name-创建标签" aria-label="Permalink to &quot;2、git tag [tag-name] -创建标签&quot;">​</a></h3><p><img src="'+$+'" alt="image-20240901221235802" loading="lazy"></p><h3 id="_3、git-push-short-name-tag-name-推送标签" tabindex="-1">3、git push [short-name] [tag-name]-<mark>推送标签</mark> <a class="header-anchor" href="#_3、git-push-short-name-tag-name-推送标签" aria-label="Permalink to &quot;3、git push [short-name] [tag-name]-==推送标签==&quot;">​</a></h3><p><img src="'+Q+'" alt="image-20240901221345791" loading="lazy"></p><h3 id="_4、git-checkout-b-newbranch-name-tag-name-检出标签" tabindex="-1">4、git checkout -b [newbranch-name] [tag-name] -<mark>检出标签</mark> <a class="header-anchor" href="#_4、git-checkout-b-newbranch-name-tag-name-检出标签" aria-label="Permalink to &quot;4、git checkout -b [newbranch-name] [tag-name] -==检出标签==&quot;">​</a></h3><p><img src="'+Y+'" alt="image-20240901221530299" loading="lazy"></p><h2 id="六、idea中使用git" tabindex="-1">六、<mark>IDEA中使用Git</mark> <a class="header-anchor" href="#六、idea中使用git" aria-label="Permalink to &quot;六、==IDEA中使用Git==&quot;">​</a></h2><p><img src="'+l+'" alt="image-20240901224103951" loading="lazy"></p><p><img src="'+r+'" alt="image-20240901224715756" loading="lazy"></p><h3 id="_1、配置git" tabindex="-1">1、配置Git <a class="header-anchor" href="#_1、配置git" aria-label="Permalink to &quot;1、配置Git&quot;">​</a></h3><p><img src="'+H+'" alt="image-20240901221944015" loading="lazy"></p><h3 id="_2、获取git仓库" tabindex="-1">2、获取Git仓库 <a class="header-anchor" href="#_2、获取git仓库" aria-label="Permalink to &quot;2、获取Git仓库&quot;">​</a></h3><p><img src="'+J+'" alt="image-20240901222501572" loading="lazy"></p><p><img src="'+Z+'" alt="image-20240901222722684" loading="lazy"></p><p><img src="'+O+'" alt="image-20240901223006395" loading="lazy"></p><h3 id="_3、本地仓库操作" tabindex="-1">3、本地仓库操作 <a class="header-anchor" href="#_3、本地仓库操作" aria-label="Permalink to &quot;3、本地仓库操作&quot;">​</a></h3><h4 id="_1将文件加入到缓存区" tabindex="-1">①将文件加入到缓存区 <a class="header-anchor" href="#_1将文件加入到缓存区" aria-label="Permalink to &quot;①将文件加入到缓存区&quot;">​</a></h4><p><img src="'+X+'" alt="image-20240901223242809" loading="lazy"></p><h4 id="_2将暂存区的文件提交到本地版本库" tabindex="-1">②将暂存区的文件提交到本地版本库 <a class="header-anchor" href="#_2将暂存区的文件提交到本地版本库" aria-label="Permalink to &quot;②将暂存区的文件提交到本地版本库&quot;">​</a></h4><p><img src="'+l+'" alt="image-20240901224103951" loading="lazy"></p><h4 id="_3查看日志" tabindex="-1">③查看日志 <a class="header-anchor" href="#_3查看日志" aria-label="Permalink to &quot;③查看日志&quot;">​</a></h4><p><img src="'+aa+'" alt="image-20240901224245577" loading="lazy"></p><h3 id="_4、远程仓库操作" tabindex="-1">4、远程仓库操作 <a class="header-anchor" href="#_4、远程仓库操作" aria-label="Permalink to &quot;4、远程仓库操作&quot;">​</a></h3><p><img src="'+r+'" alt="image-20240901224715756" loading="lazy"></p><h3 id="_5、分支操作" tabindex="-1">5、<mark>分支操作</mark> <a class="header-anchor" href="#_5、分支操作" aria-label="Permalink to &quot;5、==分支操作==&quot;">​</a></h3><h4 id="_1查看分支" tabindex="-1">①查看分支 <a class="header-anchor" href="#_1查看分支" aria-label="Permalink to &quot;①查看分支&quot;">​</a></h4><p><img src="'+ia+'" alt="image-20240901225415765" loading="lazy"></p><h4 id="_2创建分支" tabindex="-1">②创建分支 <a class="header-anchor" href="#_2创建分支" aria-label="Permalink to &quot;②创建分支&quot;">​</a></h4><p><img src="'+sa+'" alt="image-20240901225450107" loading="lazy"></p><h4 id="_3切换分支" tabindex="-1">③切换分支 <a class="header-anchor" href="#_3切换分支" aria-label="Permalink to &quot;③切换分支&quot;">​</a></h4><p><img src="'+ta+'" alt="image-20240901225559749" loading="lazy"></p><h4 id="_4将分支推送到远程仓库" tabindex="-1">④将分支推送到远程仓库 <a class="header-anchor" href="#_4将分支推送到远程仓库" aria-label="Permalink to &quot;④将分支推送到远程仓库&quot;">​</a></h4><p><img src="'+ea+'" alt="image-20240901225659741" loading="lazy"></p><h4 id="_5合并分支" tabindex="-1">⑤合并分支 <a class="header-anchor" href="#_5合并分支" aria-label="Permalink to &quot;⑤合并分支&quot;">​</a></h4><p><img src="'+na+`" alt="image-20240901225844943" loading="lazy"></p><h2 id="七、git克隆远程仓库的指定分支方法" tabindex="-1">七、git<mark>克隆</mark>远程仓库的<mark>指定分支</mark>方法 <a class="header-anchor" href="#七、git克隆远程仓库的指定分支方法" aria-label="Permalink to &quot;七、git==克隆==远程仓库的==指定分支==方法&quot;">​</a></h2><p>原文链接：<a href="https://blog.csdn.net/yujia_666/article/details/115362190" target="_blank" rel="noreferrer">https://blog.csdn.net/yujia_666/article/details/115362190</a></p><h3 id="_1、普通克隆方式" tabindex="-1">1、普通克隆方式 <a class="header-anchor" href="#_1、普通克隆方式" aria-label="Permalink to &quot;1、普通克隆方式&quot;">​</a></h3><ul><li>git clone <code>&lt;远程仓库地址&gt;</code></li><li>这种克隆方式默认是克隆master主分支，</li><li>而且通过命令 git branch --list 能看到克隆后在本地也只有这一个分支，</li><li>如果再通过新建分支再拉取指定分支，甚至可能还需要解决冲突，太繁琐。</li></ul><h3 id="_2、克隆远程指定分支" tabindex="-1">2、克隆远程指定分支 <a class="header-anchor" href="#_2、克隆远程指定分支" aria-label="Permalink to &quot;2、克隆远程指定分支&quot;">​</a></h3><p>那么，如何快速有效的直接克隆远程指定分支？</p><p>只需要一条命令：</p><p><strong>git clone -b <code>&lt;指定分支名&gt;</code> <code>&lt;远程仓库地址&gt;</code></strong></p><p>git clone -b eeat/ssion <a href="https://gitxxx.com/orm/mmm.git" target="_blank" rel="noreferrer">https://gitxxx.com/orm/mmm.git</a> 会自动在克隆该分支在本地，同样克隆后本地只有这一个分支。</p><h3 id="_3、常用git配置命令" tabindex="-1">3、<mark>常用git配置命令</mark> <a class="header-anchor" href="#_3、常用git配置命令" aria-label="Permalink to &quot;3、==常用git配置命令==&quot;">​</a></h3><p>Git基础使用教程 - 老_张 - 博客园</p><p>首先，我们创建dev分支，然后切换到dev分支：</p><div class="language-shell vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">$</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> git</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> checkout</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -b</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> dev</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Switched</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> to</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> a</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> new</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> branch</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;dev&#39;</span></span></code></pre></div><p>git checkout命令加上-b参数表示创建并切换，相当于以下两条命令：</p><div class="language-shell vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">$</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> git</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> branch</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> dev</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">$</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> git</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> checkout</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> dev</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Switched</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> to</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> branch</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;dev&#39;</span></span></code></pre></div><p>然后，用git branch命令查看当前分支：</p><div class="language-shell vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">$</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> git</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> branch</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> dev</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  master</span></span></code></pre></div><p>git branch命令会列出所有分支，当前分支前面会标一个*号。</p><p>然后，我们就可以在dev分支上正常提交，比如对readme.txt做个修改，加上一行：</p><div class="language-shell vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Creating</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> a</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> new</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> branch</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> is</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> quick.</span></span></code></pre></div><p>然后提交：</p><div class="language-shell vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">$</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> git</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> add</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> readme.txt</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> </span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">$</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> git</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> commit</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -m</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;branch test&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[dev b17d20e] branch test</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> 1</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> file</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> changed,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> insertion</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">$</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> git</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> push</span></span></code></pre></div><p>现在，dev分支的工作完成，我们就可以切换回master分支：</p><div class="language-shell vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">$</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> git</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> checkout</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> master</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Switched</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> to</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> branch</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;master&#39;</span></span></code></pre></div><p>切换回master分支后，再查看一个readme.txt文件，刚才添加的内容不见了！因为那个提交是在dev分支上，而master分支此刻的提交点并没有变：</p><p><img src="`+la+`" alt="image-20240905160429304" loading="lazy"></p><p>现在，我们把dev分支的工作成果<strong>合并到master分支</strong>上：</p><div class="language-shell vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">$</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> git</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> merge</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> dev</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Updating</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> d46f35e..b17d20e</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Fast-forward</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> readme.txt</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> |</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> 1</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> +</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> 1</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> file</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> changed,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> insertion</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>git merge命令用于合并指定分支到当前分支。合并后，再查看readme.txt的内容，就可以看到，和dev分支的最新提交是完全一样的。</p><p>注意到上面的<strong>Fast-forward</strong>信息，Git告诉我们，<strong>这次合并是“快进模式”</strong>，也就是直接把master指向dev的当前提交，所以合并速度非常快。</p><p>当然，也不是每次合并都能Fast-forward，我们后面会讲其他方式的合并。</p><p>合并完成后，就可以放心地删除dev分支了：</p><div class="language-shell vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">$</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> git</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> branch</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -d</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> dev</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Deleted</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> branch</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> dev</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (was </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">b17d20e</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">).</span></span></code></pre></div><p>删除后，查看branch，就只剩下master分支了：</p><div class="language-shell vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">$</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> git</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> branch</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> master</span></span></code></pre></div><p>因为创建、合并和删除分支非常快，所以Git鼓励你使用分支完成某个任务，合并后再删掉分支，这和直接在master分支上工作效果是一样的，但过程更安全。</p><p>switch 我们注意到切换分支使用git checkout <code>&lt;branch&gt;</code>，而前面讲过的撤销修改则是git checkout -- <code>&lt;file&gt;</code>，同一个命令，有两种作用，确实有点令人迷惑。</p><p>实际上，切换分支这个动作，用switch更科学。因此，最新版本的Git提供了新的git switch命令来切换分支：</p><p>创建并切换到新的dev分支，可以使用：</p><div class="language-shell vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">$</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> git</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> switch</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -c</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> dev</span></span></code></pre></div><p>直接切换到已有的master分支，可以使用：</p><div class="language-shell vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">$</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> git</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> switch</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> master</span></span></code></pre></div><p>使用新的git switch命令，比git checkout要更容易理解。</p><h4 id="小结" tabindex="-1">小结 <a class="header-anchor" href="#小结" aria-label="Permalink to &quot;小结&quot;">​</a></h4><p>Git鼓励大量使用分支：</p><ul><li><p>查看分支：git branch</p></li><li><p>创建分支：git branch <code>&lt;name&gt;</code></p></li><li><p>切换分支：git checkout <code>&lt;name&gt;</code>或者git switch <code>&lt;name&gt;</code></p></li><li><p>创建+切换分支：git checkout -b <code>&lt;name&gt;</code>或者git switch -c <code>&lt;name&gt;</code></p></li><li><p>合并某分支到当前分支：git merge <code>&lt;name&gt;</code></p></li><li><p>删除分支：git branch -d <code>&lt;name&gt;</code></p></li></ul><h2 id="八、git提示-warning-lf-will-be-replaced-by-crlf-最详细解释-解决方案" tabindex="-1">八、Git提示“warning: <mark>LF will be replaced by CRLF</mark>”最详细解释+解决方案 <a class="header-anchor" href="#八、git提示-warning-lf-will-be-replaced-by-crlf-最详细解释-解决方案" aria-label="Permalink to &quot;八、Git提示“warning: ==LF will be replaced by CRLF==”最详细解释+解决方案&quot;">​</a></h2><p>文章地址：<a href="https://zhuanlan.zhihu.com/p/586324681" target="_blank" rel="noreferrer">Git提示“warning: LF will be replaced by CRLF”最详细解释+解决方案 - 知乎 (zhihu.com)</a></p><h3 id="_1、解决办法" tabindex="-1">1、解决办法 <a class="header-anchor" href="#_1、解决办法" aria-label="Permalink to &quot;1、解决办法&quot;">​</a></h3><p>如果只是在window上</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">以下任选其一</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">关闭自动转换（当前仓库）</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">git</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> config</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> core.autocrlf</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> false</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">关闭自动转换（全局仓库）</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">git</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> config</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> --global</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> core.autocrlf</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> false</span></span></code></pre></div><p>如果需要转换，设置为true也可以 只是警告 看起来难看</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">关闭自动转换（当前仓库）</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">git</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> config</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> core.autocrlf</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> true</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">关闭自动转换（全局仓库）</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">git</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> config</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> --global</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> core.autocrlf</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> true</span></span></code></pre></div><p>检查git的设置结果</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">git</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> config</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> core.autocrlf</span></span></code></pre></div><h3 id="_2、warning-lf-will-be-replaced-by-crlf" tabindex="-1">2、warning: <mark>LF</mark> will be replaced by <mark>CRLF</mark> <a class="header-anchor" href="#_2、warning-lf-will-be-replaced-by-crlf" aria-label="Permalink to &quot;2、warning: ==LF== will be replaced by ==CRLF==&quot;">​</a></h3><h5 id="_1-问题描述" tabindex="-1">1.问题描述： <a class="header-anchor" href="#_1-问题描述" aria-label="Permalink to &quot;1.问题描述：&quot;">​</a></h5><p>windows平台下使用git add，git deploy 文件时经常出现“warning: LF will be replaced by CRLF” 的提示</p><p><img src="`+ra+'" alt="image-20240902144827481" loading="lazy"></p><h5 id="_2-注解" tabindex="-1">2.注解： <a class="header-anchor" href="#_2-注解" aria-label="Permalink to &quot;2.注解：&quot;">​</a></h5><p>(1)<a href="https://zhida.zhihu.com/search?q=%E6%8D%A2%E8%A1%8C%E7%AC%A6&amp;zhida_source=entity&amp;is_preview=1" target="_blank" rel="noreferrer">换行符</a>‘\\n’和回车符‘\\r’</p><p>在计算机还没有出现之前，有一种叫做<a href="https://zhida.zhihu.com/search?q=%E7%94%B5%E4%BC%A0%E6%89%93%E5%AD%97%E6%9C%BA&amp;zhida_source=entity&amp;is_preview=1" target="_blank" rel="noreferrer">电传打字机</a>（Teletype Model 33）的玩意，每秒钟可以打10个字符。但是它有一个问题，就是打完一行换行的时候，要用去0.2秒，正好可以打两个字符。要是在这0.2秒里面，又有新的字符传过来，那么这个字符将丢失。</p><p>于是，研制人员想了个办法解决这个问题，就是在每行后面加两个表示结束的字符。一个叫做“回车”，告诉打字机把打印头定位在左边界；另一个叫做“换行”，告诉打字机把纸向下移一行。</p><p><strong>(A)回车符就是回到一行的开头，用符号r表示，十进制ASCII代码是13，<a href="https://zhida.zhihu.com/search?q=%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6&amp;zhida_source=entity&amp;is_preview=1" target="_blank" rel="noreferrer">十六进制</a>代码为0x0D，回车（return）；</strong></p><p><strong>(B)换行符就是另起一行，用n符号表示，ASCII代码是10，十六制为0x0A， 换行（newline）。</strong></p><h5 id="_2-lf和crlf区别" tabindex="-1">(2)LF和CRLF区别 <a class="header-anchor" href="#_2-lf和crlf区别" aria-label="Permalink to &quot;(2)LF和CRLF区别&quot;">​</a></h5><p><strong>LF: Line Feed换行</strong></p><p><strong>feed v.喂养,供给;将(信息)输入 line feed直译是”将行输入”,再意译”换行”</strong></p><p><strong>CRLF: Carriage Return Line Feed 回车换行</strong></p><p>Carriage n.马车,火车车厢;运输费用 在carriage return中,carriage译为“车”,return译为“回”</p><p>在过去的机械打字机上有个部件叫「字车」（Typewriter carriage），每打一个字符，字车前进一格，打完一行后，我们需要让字车回到起始位置，而“Carriage Return”键最早就是这个作用，因此被直接翻译为「回车」。尽管后来回车键的作用已经不止” 倒回字车”那么简单，但这个译名一直被保留下来。</p><h5 id="_3-分析问题" tabindex="-1">3.分析问题 <a class="header-anchor" href="#_3-分析问题" aria-label="Permalink to &quot;3.分析问题&quot;">​</a></h5><p>这句警告出现的原因：我们在Windows平台下git add任意<strong>Windows平台编辑过的代码文本的换行默认都是CRLF</strong>，所以一般git add不会出错。但是如果如下的(i)或者(ii)发生了，那我们再进行git add这个LF换行的文件时，会出现这个警告&quot; LF will be replaced by CRLF in …&quot;。</p><ul><li><strong>(i)我们的团队成员是Linux/Mac平台并参与了项目的git提交</strong></li><li><strong>(ii)我们Windows平台的某些软件会生成换行是LF的代码文本(如<a href="https://zhida.zhihu.com/search?q=%E6%9D%8E%E4%BF%8A%E5%BE%B7&amp;zhida_source=entity&amp;is_preview=1" target="_blank" rel="noreferrer">李俊德</a>git add的是Webstorm生成的HTML项目中隐藏文件夹.idea中的workspace.xml,这个xml文件换行是LF</strong></li></ul><p>(1)不同操作系统下，处理行尾结束符的方法是不同的：</p><ul><li><p><strong>(A)Windows和Dos下：使用回车（CR）和换行（LF）两个字符来结束一行，回车+换行(CR+LF)，即“\\r\\n”；</strong></p></li><li><p><strong>(B)Unix和mc下：只使用换行（LF）一个字符来结束一行，即“\\n”；</strong></p></li><li><p><strong>(最早Mac每行结尾是回车CR 即&#39;\\r&#39;，后mac os x 也投奔了 unix)</strong></p></li></ul><p>(2)Git下处理“换行”（line ending）</p><p>​ <strong>core.autocrlf是git中负责处理line ending的变量，可以设置3个值：true，false，input。</strong></p><ul><li><p>(A)设置为true【config --global core.autocrlf true】</p><p>​ **当设置成true时，这意味着你在任何时候添加(add)文件到git仓库时，git都会视为它是一个<a href="https://zhida.zhihu.com/search?q=%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6&amp;zhida_source=entity&amp;is_preview=1" target="_blank" rel="noreferrer">文本文件</a>(text file)。**它将把crlf变成LF。</p></li><li><p>(B)设置为false【config --global core.autocrlf false】</p><p>​ 当设置成false时，line endings将不做转换操作。文本文件保持原来的样子。</p></li><li><p>(C)设置为input时，添加文件git仓库时，git把crlf编程lf。当有人Check代码时还是lf方式。因此在window操作系统下，不要使用这个设置。</p></li></ul><h5 id="_4-此问题的负面影响" tabindex="-1">4.此问题的负面影响 <a class="header-anchor" href="#_4-此问题的负面影响" aria-label="Permalink to &quot;4.此问题的负面影响&quot;">​</a></h5><p>格式化与多余的空白字符，特别是在跨平台情况下，有时候是一个令人发指的问题。由于<a href="https://zhida.zhihu.com/search?q=%E7%BC%96%E8%BE%91%E5%99%A8&amp;zhida_source=entity&amp;is_preview=1" target="_blank" rel="noreferrer">编辑器</a>的不同或者文件行尾的换行符在 Windows 下被替换了，一些细微的空格变化会不经意地混入提交，造成麻烦。虽然这是小问题，但会极大地扰乱跨平台协作。</p><p>假如你正在Windows上写程序;又或者你正在和其他人合作，他们在Windows上编程，而你却在其他系统上，在这些情况下，你可能会遇到行尾结束符问题。此问题的全部负面影响如下：</p><p><strong>(1)一个直接后果是，Unix/Mac系统下的一个“多行文本”文件在Windows里打开的话，“多行文本”会变成“一行”。（原因：Unix/Mac换行只用了换行符‘\\n’，而Windows的换行要求是回车换行符’\\r\\n’，因此Unix/Mac中的“多行文本”的换行不符合Windows的规则，所以Windows对这些不符合换行规则的“多行文本”全部按照“没有换行”处理，所以导致“多行文本”会变成“一行”）</strong></p><p><strong>(2)而Windows里的文件在Unix/Mac下打开的话，在每行的结尾可能会多出一个^M符号。</strong></p><p><strong>(3)Linux保存的文件在windows上用记事本看的话会出现黑点。</strong></p><p>5.解决此问题的方案</p><p>(1)如果我们目前是Window平台并出现该警告，啥也别做就行，虽然这个警告难看，但这个警告能保证我们项目团队正常跨系统git操作代码</p><p>因为git的Windows <a href="https://zhida.zhihu.com/search?q=%E5%AE%A2%E6%88%B7%E7%AB%AF&amp;zhida_source=entity&amp;is_preview=1" target="_blank" rel="noreferrer">客户端</a>基本都会默认设置 core.autocrlf=true（我们可通过git config core.autocrlf命令查询我们的Windows上该属性是否默认true。如不是true,通过config --global core.autocrlf true命令设置该属性为true），而“<strong>core.autocrlf=true</strong>”有以下3个功能来避免我们出错：</p><ul><li><p>(A)在“把 modified修改过的文件git add到暂存区stage”时，Git自动把LF转换成CRLF,并给出那条警告”LF will be replaced by CRLF”</p></li><li><p>(B)在把modified修改过的文件由暂存区(stage) 提交(commit)到版本库/仓库(repository)”时，Git自动把CRLF转换成LF</p></li><li><p>(C)在“用 检出/git checkout切换到指定分支 或 git clone克隆远程版本库”来加载代码时，Git自动把LF转换成CRLF</p></li></ul><p>提到的那句警告：“IF will be replaced by CRLF in <code>&lt;file-name&gt;</code>”</p><p>这句警告的下面其实还有一句很重要的话：The file will have its original line endings in your working directory.</p><p>(翻译：&quot;在工作区里，这个文件会保留它原本的换行符&quot;)</p><p>(2)如果我们是Linux 或 Mac平台,我们不需要5(1)(C)的功能“在检出或克隆远程版本库时，Git自动把LF转换成CRLF”。然而当一个CRLF作为行结束符的文件在我们的Linux 或 Mac平台不小心被引入时，你肯定想让 Git 修正。 所以，你可以通过config --global core.autocrlf input命令把 core.autocrlf 设置成 input 来告诉 Git 在提交(commit)时把CRLF转换成LF，检出(git checkout)时不转换</p><p>(1)+(2):这样在 Windows 上的检出(checkout)文件中会保留CRLF，而在 Mac 和 Linux 上，以及版本库中会保留LF，从而保证我们项目团队正常跨系统git操作代码</p><h1 id="🚀常用例子-push本地项目" tabindex="-1">🚀常用例子-Push本地项目 <a class="header-anchor" href="#🚀常用例子-push本地项目" aria-label="Permalink to &quot;🚀常用例子-Push本地项目&quot;">​</a></h1>',195)),s(i),a[2]||(a[2]=t(`<p>你的错误 <code>fatal: your current branch &#39;main&#39; does not have any commits yet</code> 说明当前 <code>main</code> 分支是空的，没有任何提交，因此无法推送。你可以按照以下步骤解决：</p><hr><h3 id="解决方案" tabindex="-1"><strong>解决方案</strong> <a class="header-anchor" href="#解决方案" aria-label="Permalink to &quot;**解决方案**&quot;">​</a></h3><h4 id="_1-添加文件并提交-如果还没有提交过" tabindex="-1"><strong>1. 添加文件并提交</strong>（如果还没有提交过） <a class="header-anchor" href="#_1-添加文件并提交-如果还没有提交过" aria-label="Permalink to &quot;**1. 添加文件并提交**（如果还没有提交过）&quot;">​</a></h4><p>执行：</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">git</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> add</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> .</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">git</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> commit</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -m</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;Initial commit&quot;</span></span></code></pre></div><p>这样你的 <code>main</code> 分支就会有第一个提交。</p><hr><h4 id="_2-重新推送到远程仓库" tabindex="-1"><strong>2. 重新推送到远程仓库</strong> <a class="header-anchor" href="#_2-重新推送到远程仓库" aria-label="Permalink to &quot;**2. 重新推送到远程仓库**&quot;">​</a></h4><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">git</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> push</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -u</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> origin</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> main</span></span></code></pre></div><p>如果仍然有问题，尝试：</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">git</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> push</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> origin</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> main</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> --force</span></span></code></pre></div><p>⚠ <strong>注意</strong>：<code>--force</code> 可能会覆盖远程仓库的内容，所以请谨慎使用。</p><hr><h3 id="完整步骤-如果从零开始" tabindex="-1"><strong><mark>完整步骤</mark>（如果从零开始）</strong> <a class="header-anchor" href="#完整步骤-如果从零开始" aria-label="Permalink to &quot;**==完整步骤==（如果从零开始）**&quot;">​</a></h3><p>如果你还没有初始化 Git 仓库，完整步骤如下：</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">cd</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /path/to/your-project</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  # 进入你的项目目录</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">git</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> init</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">                  # 初始化 Git 仓库</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">git</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> add</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> .</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">                 # 添加所有文件</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">git</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> commit</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -m</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;Initial commit&quot;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  # 提交代码</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">git</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> branch</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -M</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> main</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        # 确保分支名是 main</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">git</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> remote</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> add</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> origin</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> https://github.com/XiaoPeng03182/Auto_Backup_Tools.git</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  # 关联远程仓库</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">git</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> push</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -u</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> origin</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> main</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">   # 推送代码</span></span></code></pre></div><p>这样你的代码就成功推送到 GitHub 了！🚀</p><h1 id="🚀常用命令的区别" tabindex="-1">🚀常用命令的区别 <a class="header-anchor" href="#🚀常用命令的区别" aria-label="Permalink to &quot;🚀常用命令的区别&quot;">​</a></h1>`,19)),s(i),a[3]||(a[3]=t(`<p>Git 中的 <code>merge</code>、<code>rebase</code>、<code>push</code>、<code>pull</code> 和 <code>fetch</code> 都是 Git 的核心命令，它们的作用和适用场景如下：</p><hr><h2 id="_1-git-merge-合并分支" tabindex="-1"><strong>1. <code>git merge</code>（合并分支）</strong> <a class="header-anchor" href="#_1-git-merge-合并分支" aria-label="Permalink to &quot;**1. \`git merge\`（合并分支）**&quot;">​</a></h2><h3 id="作用" tabindex="-1"><strong>作用</strong> <a class="header-anchor" href="#作用" aria-label="Permalink to &quot;**作用**&quot;">​</a></h3><ul><li><code>merge</code> 用于合并不同的分支，将某个分支的更改合并到当前分支。</li><li>默认采用 <strong>三方合并（3-way merge）</strong>，会保留历史提交记录，并可能生成 <strong>一个新的合并提交</strong>。</li></ul><h3 id="适用场景" tabindex="-1"><strong>适用场景</strong> <a class="header-anchor" href="#适用场景" aria-label="Permalink to &quot;**适用场景**&quot;">​</a></h3><p>✅ <strong>多人协作</strong>：当你在本地开发完一个功能后，希望合并到 <code>main</code> 或 <code>develop</code> 分支。 ✅ <strong>保持历史完整</strong>：<code>merge</code> 方式不会修改提交历史，只会新增一个合并提交（merge commit）。</p><h3 id="使用示例" tabindex="-1"><strong>使用示例</strong> <a class="header-anchor" href="#使用示例" aria-label="Permalink to &quot;**使用示例**&quot;">​</a></h3><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 切换到主分支</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">git</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> checkout</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  </span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 合并 feature 分支到 main</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">git</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> merge</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> feature_branch</span></span></code></pre></div><hr><h2 id="_2-git-rebase-变基" tabindex="-1"><strong>2. <code>git rebase</code>（变基）</strong> <a class="header-anchor" href="#_2-git-rebase-变基" aria-label="Permalink to &quot;**2. \`git rebase\`（变基）**&quot;">​</a></h2><h3 id="作用-1" tabindex="-1"><strong>作用</strong> <a class="header-anchor" href="#作用-1" aria-label="Permalink to &quot;**作用**&quot;">​</a></h3><ul><li><code>rebase</code> 也是用于合并不同的分支，但它通过 <strong>修改提交历史</strong>，将当前分支的提交 <strong>“重演”</strong> 在目标分支的最新提交之上。</li><li>这样能让提交历史更加 <strong>线性</strong>，避免 <code>merge</code> 带来的额外合并提交。</li></ul><h3 id="适用场景-1" tabindex="-1"><strong>适用场景</strong> <a class="header-anchor" href="#适用场景-1" aria-label="Permalink to &quot;**适用场景**&quot;">​</a></h3><p>✅ <strong>清理提交历史</strong>：保持主分支的提交历史整洁，避免过多的 <code>merge commit</code>。 ✅ <strong>避免分叉</strong>：<code>rebase</code> 会让你的提交紧跟目标分支，而不会产生合并提交。 ❌ <strong>不要在已推送的公共分支上 <code>rebase</code></strong>，否则会导致团队成员的分支冲突！</p><h3 id="使用示例-1" tabindex="-1"><strong>使用示例</strong> <a class="header-anchor" href="#使用示例-1" aria-label="Permalink to &quot;**使用示例**&quot;">​</a></h3><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 切换到 feature 分支</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">git</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> checkout</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> feature_branch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  </span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 将 feature_branch 变基到 main</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">git</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> rebase</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> main</span></span></code></pre></div><p>如果发生冲突：</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 手动解决冲突后，继续 rebase</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">git</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> add</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> .</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">git</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> rebase</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> --continue</span></span></code></pre></div><hr><h2 id="_3-git-push-推送代码" tabindex="-1"><strong>3. <code>git push</code>（推送代码）</strong> <a class="header-anchor" href="#_3-git-push-推送代码" aria-label="Permalink to &quot;**3. \`git push\`（推送代码）**&quot;">​</a></h2><h3 id="作用-2" tabindex="-1"><strong>作用</strong> <a class="header-anchor" href="#作用-2" aria-label="Permalink to &quot;**作用**&quot;">​</a></h3><ul><li><code>push</code> 用于 <strong>将本地的提交上传到远程仓库</strong>，使团队成员能够看到你的更改。</li></ul><h3 id="适用场景-2" tabindex="-1"><strong>适用场景</strong> <a class="header-anchor" href="#适用场景-2" aria-label="Permalink to &quot;**适用场景**&quot;">​</a></h3><p>✅ <strong>提交代码到远程仓库</strong> ✅ <strong>分享你的修改给团队</strong></p><h3 id="使用示例-2" tabindex="-1"><strong>使用示例</strong> <a class="header-anchor" href="#使用示例-2" aria-label="Permalink to &quot;**使用示例**&quot;">​</a></h3><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 推送当前分支到远程仓库</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">git</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> push</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> origin</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> branch_name</span></span></code></pre></div><p>⚠ <strong>如果远程分支有更新，push 可能会失败</strong>，需要先 <code>pull</code> 远程最新代码。</p><hr><h2 id="_4-git-pull-拉取最新代码" tabindex="-1"><strong>4. <mark><code>git pull</code></mark>（拉取最新代码）</strong> <a class="header-anchor" href="#_4-git-pull-拉取最新代码" aria-label="Permalink to &quot;**4. ==\`git pull\`==（拉取最新代码）**&quot;">​</a></h2><h3 id="作用-3" tabindex="-1"><strong>作用</strong> <a class="header-anchor" href="#作用-3" aria-label="Permalink to &quot;**作用**&quot;">​</a></h3><ul><li><mark><code>pull</code> = <code>fetch</code> + <code>merge</code></mark></li><li><code>git pull</code> 从远程仓库拉取最新代码，<strong>并自动合并到本地分支</strong>。</li></ul><h3 id="适用场景-3" tabindex="-1"><strong>适用场景</strong> <a class="header-anchor" href="#适用场景-3" aria-label="Permalink to &quot;**适用场景**&quot;">​</a></h3><p>✅ <strong>获取最新代码</strong>，确保本地分支与远程同步。 ✅ <strong>适用于多人协作</strong>，确保你的代码基于最新的远程版本。</p><h3 id="使用示例-3" tabindex="-1"><strong>使用示例</strong> <a class="header-anchor" href="#使用示例-3" aria-label="Permalink to &quot;**使用示例**&quot;">​</a></h3><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 拉取并合并远程 main 分支的最新代码</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">git</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> pull</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> origin</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> main</span></span></code></pre></div><p>⚠ <strong>如果远程代码和本地代码有冲突，可能需要手动解决冲突。</strong></p><hr><h2 id="_5-git-fetch-获取远程最新代码" tabindex="-1"><strong>5. <code>git fetch</code>（获取远程最新代码）</strong> <a class="header-anchor" href="#_5-git-fetch-获取远程最新代码" aria-label="Permalink to &quot;**5. \`git fetch\`（获取远程最新代码）**&quot;">​</a></h2><h3 id="作用-4" tabindex="-1"><strong>作用</strong> <a class="header-anchor" href="#作用-4" aria-label="Permalink to &quot;**作用**&quot;">​</a></h3><ul><li><code>fetch</code> <mark>只下载远程仓库的最新代码</mark>，但==<strong>不会自动合并</strong>到本地分支==。</li><li>适用于想 <strong>先查看远程更新</strong>，再决定是否合并。</li></ul><h3 id="适用场景-4" tabindex="-1"><strong>适用场景</strong> <a class="header-anchor" href="#适用场景-4" aria-label="Permalink to &quot;**适用场景**&quot;">​</a></h3><p>✅ <strong>想查看远程更新但不影响当前分支</strong>。 ✅ <strong>在本地代码还没准备好合并时</strong>，可以先 <code>fetch</code> 再手动合并。</p><h3 id="使用示例-4" tabindex="-1"><strong>使用示例</strong> <a class="header-anchor" href="#使用示例-4" aria-label="Permalink to &quot;**使用示例**&quot;">​</a></h3><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 获取远程仓库的最新数据，但不合并</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">git</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> fetch</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> origin</span></span></code></pre></div><p>然后可以用 <code>git diff</code> 查看有哪些变化：</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">git</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> diff</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> origin/main</span></span></code></pre></div><p>如果确定要合并，再执行：</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">git</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> merge</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> origin/main</span></span></code></pre></div><hr><h2 id="总结对比" tabindex="-1"><strong>总结对比</strong> <a class="header-anchor" href="#总结对比" aria-label="Permalink to &quot;**总结对比**&quot;">​</a></h2><table tabindex="0"><thead><tr><th>命令</th><th>作用</th><th>是否改变提交历史</th><th>是否自动合并</th><th>适用场景</th></tr></thead><tbody><tr><td><code>merge</code></td><td>合并分支</td><td>❌（保留历史）</td><td>✅（产生合并提交）</td><td>多人协作，合并新功能</td></tr><tr><td><code>rebase</code></td><td>变基</td><td>✅（重写历史）</td><td>❌（修改提交顺序）</td><td>保持提交记录整洁</td></tr><tr><td><code>push</code></td><td>推送代码到远程</td><td>❌</td><td>❌</td><td>上传本地代码</td></tr><tr><td><code>pull</code></td><td>拉取远程代码并合并</td><td>❌</td><td>✅</td><td>获取最新代码并自动合并</td></tr><tr><td><code>fetch</code></td><td>获取远程代码但不合并</td><td>❌</td><td>❌</td><td>查看远程更新</td></tr></tbody></table><hr><h2 id="最佳实践" tabindex="-1"><mark><strong>最佳实践</strong></mark> <a class="header-anchor" href="#最佳实践" aria-label="Permalink to &quot;==**最佳实践**==&quot;">​</a></h2><p>1️⃣ <strong>开发新功能时</strong></p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 创建新分支</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">git</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> checkout</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -b</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> feature_branch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  </span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 开发完成后，提交代码</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">git</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> commit</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -m</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;Add new feature&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  </span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 拉取最新代码，避免冲突</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">git</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> pull</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> --rebase</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> origin</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  </span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 推送到远程仓库</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">git</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> push</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> origin</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> feature_branch</span></span></code></pre></div><p>2️⃣ <strong>合并分支</strong></p><ul><li>如果你想保留历史记录：使用 <code>merge</code></li><li>如果你想保持提交记录整洁：使用 <code>rebase</code></li></ul><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">git</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> checkout</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> main</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">git</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> merge</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> feature_branch</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  # 或 git rebase feature_branch</span></span></code></pre></div><p>3️⃣ <strong>保持代码最新</strong></p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">git</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> fetch</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> origin</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  </span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">git</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> diff</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> origin/main</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  # 查看差异</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">git</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> pull</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> origin</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> main</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  # 拉取最新代码</span></span></code></pre></div><p>🚀 <strong>推荐：<code>fetch</code> + <code>merge</code>/<code>rebase</code></strong> 代替 <code>pull</code>，可以更灵活地管理更新。</p><h1 id="🚀如何使用-git-进行多人协作开发-全流程图解" tabindex="-1">🚀如何使用 Git 进行<mark>多人协作开发</mark>（全流程图解） <a class="header-anchor" href="#🚀如何使用-git-进行多人协作开发-全流程图解" aria-label="Permalink to &quot;🚀如何使用 Git 进行==多人协作开发==（全流程图解）&quot;">​</a></h1>`,63)),s(i),a[4]||(a[4]=t('<p>原文链接：<a href="https://blog.csdn.net/whc18858/article/details/133209975" target="_blank" rel="noreferrer">https://blog.csdn.net/whc18858/article/details/133209975</a></p><p>在软件开发中，多人协作是一项必不可少的任务。而 Git 作为目前最受欢迎的分布式版本控制工具，提供了强大的功能和灵活的工作流程，使得多人协作开发变得更加高效。本篇博客将带你实践如何正确使用 Git 进行多人协作开发</p><p>在本篇博客中，你将学到以下内容：</p><ul><li>Feature Branching 分支管理策略</li><li>多人单分支开发与多人多分支开发的差别</li><li>如何安全的解决合并冲突</li></ul><h2 id="_1、分支管理策略" tabindex="-1">1、分支管理策略 <a class="header-anchor" href="#_1、分支管理策略" aria-label="Permalink to &quot;1、分支管理策略&quot;">​</a></h2><p>Git分支策略允许开发人员在一个项目上进行协作，同时跟踪更改并维护多个版本的代码库。主流的分支管理策略有 Trunk-Based Development、Feature Branching、Git Flow等等，本文将基于较为简单的 Feature Branching 分支管理策略展开。虽然分支管理策略多种多样，但最好的策略一定是与你的团队特征和项目需求相匹配的。</p><h3 id="_1-什么是feature-branching" tabindex="-1">1.什么是Feature Branching？ <a class="header-anchor" href="#_1-什么是feature-branching" aria-label="Permalink to &quot;1.什么是Feature Branching？&quot;">​</a></h3><p>在实际开发中，master 分支非常强调环境的稳定性。因此当我们要开发新的功能或者特性时，需要从 master 分支上拉取 feature 分支，这样开发者就能在 feature 分支上独立开发而不影响主分支。当完成开发后，需要提交 pull request 将 feature 分支合并回 master 分支中。 通过 pull request ，仓库中的其他成员能对即将 merge 的代码进行审核并提出建议，从而保证了安全可靠性。</p><p><img src="'+ha+'" alt="image-20250328144417642" loading="lazy"></p><h3 id="_2-feature-branching如何工作" tabindex="-1">2.Feature Branching如何工作？ <a class="header-anchor" href="#_2-feature-branching如何工作" aria-label="Permalink to &quot;2.Feature Branching如何工作？&quot;">​</a></h3><ul><li><p>创建 feature 分支：feature分支一定是从 master 分支上拉取的</p></li><li><p>在 feature 分支上完成开发：通常一个分支就对应着一个特定的功能</p></li><li><p>提交 pull request：请求将分支合并回 master 分支</p></li><li><p>审查批准：其他开发人员如果对你的代码满意的话，就会同意将你的分支合并到 master 分支。通过代码审查，我们通常能在分支 merge 回主分支前发现错误</p></li><li><p>清理：完成开发后，应该及时将没用的 feature 分支删除，保持代码仓库的整洁</p></li></ul><p>下面将结合具体的例子为大家逐步骤实践上面的流程，同时带大家体会多人在单分支上开发和在多分支上开发的区别</p><h2 id="多人协作一-单分支" tabindex="-1">多人协作一：<mark>单分支</mark> <a class="header-anchor" href="#多人协作一-单分支" aria-label="Permalink to &quot;多人协作一：==单分支==&quot;">​</a></h2><ul><li>任务：开发者A和开发者B在同一分支 feature 下开发。开发者A在 README 中增加一行 aaa，开发者B在 README 中增加一行 bbb</li></ul><h3 id="_1-准备工作" tabindex="-1">1.准备工作 <a class="header-anchor" href="#_1-准备工作" aria-label="Permalink to &quot;1.准备工作&quot;">​</a></h3><p><strong>场景</strong>：开发者A在创建分支前就克隆过远程仓库，而开发者B则在创建分支后才克隆远程仓库</p><p><img src="'+pa+'" alt="img" loading="lazy"></p><p><img src="'+oa+'" alt="在这里插入图片描述" loading="lazy"></p><p>在实际开发中，如果要进行多人协作开发，首先需要将其他成员添加进来</p><p><img src="'+da+'" alt="在这里插入图片描述" loading="lazy"></p><h3 id="_2-创建分支" tabindex="-1">2.创建分支 <a class="header-anchor" href="#_2-创建分支" aria-label="Permalink to &quot;2.创建分支&quot;">​</a></h3><p>创建分支的方式有两种：</p><ul><li><p>在远程仓库直接创建</p></li><li><p>在本地创建分支 xxx 后使用指令 git push origin xxx 在远端创建一个与本地 xxx 分支对应的 xxx 分支</p></li></ul><h4 id="_1-在单分支场景中-我们首先采用方法一创建分支" tabindex="-1">1）在单分支场景中，我们首先采用方法一创建分支 <a class="header-anchor" href="#_1-在单分支场景中-我们首先采用方法一创建分支" aria-label="Permalink to &quot;1）在单分支场景中，我们首先采用方法一创建分支&quot;">​</a></h4><p><img src="'+ga+'" alt="在这里插入图片描述" loading="lazy"></p><p><img src="'+ca+'" alt="在这里插入图片描述" loading="lazy"></p><h4 id="_2-使用指令-git-branch-r-指令可以查看远程仓库中的所有分支-但是对于开发者a而言只能看到-master-分支" tabindex="-1">2）使用指令 git branch -r 指令可以查看远程仓库中的所有分支，但是对于开发者A而言只能看到 master 分支 <a class="header-anchor" href="#_2-使用指令-git-branch-r-指令可以查看远程仓库中的所有分支-但是对于开发者a而言只能看到-master-分支" aria-label="Permalink to &quot;2）使用指令 git branch -r 指令可以查看远程仓库中的所有分支，但是对于开发者A而言只能看到 master 分支&quot;">​</a></h4><p><img src="'+ka+'" alt="在这里插入图片描述" loading="lazy"></p><h4 id="_3-原因也不难理解-开发者a是在创建-feature-分支前克隆远程仓库的-因此当前是落后于远程仓库的最新版本。我们需要使用-git-pull-指令来更新分支信息" tabindex="-1">3）原因也不难理解，开发者A是在创建 feature 分支前克隆远程仓库的，因此当前是落后于远程仓库的最新版本。我们需要使用 git pull 指令来更新分支信息： <a class="header-anchor" href="#_3-原因也不难理解-开发者a是在创建-feature-分支前克隆远程仓库的-因此当前是落后于远程仓库的最新版本。我们需要使用-git-pull-指令来更新分支信息" aria-label="Permalink to &quot;3）原因也不难理解，开发者A是在创建 feature 分支前克隆远程仓库的，因此当前是落后于远程仓库的最新版本。我们需要使用 git pull 指令来更新分支信息：&quot;">​</a></h4><p><img src="'+ma+'" alt="在这里插入图片描述" loading="lazy"></p><blockquote><p>🎯[说明]：</p><p>git pull 指令具有以下两个作用：</p><p>拉取远程分支中的最新提交，并自动合并 （需要建立追踪关系）</p><p>更新远程仓库的分支信息（不需要建立追踪关系）</p></blockquote><p>如何理解建立追踪关系呢？git pull 指令的完整用法是 <strong>git pull <code>&lt;远程主机名&gt;</code> <code>&lt;远程分支名&gt;</code>:<code>&lt;本地分支名&gt;</code></strong>，当我们完整使用 git pull 指令时，不需要考虑建立追踪关系的问题，而当我们简写为 git pull 时，本地分支默认为当前的工作分支，远程分支为与之建立链接的远程分支。当我们 clone 远程仓库时其实自动建立了本地master分支与远程master分支的追踪关系——即链接，因此我们可以采用简写的方式。</p><p>📌[建议]: 在开发前首先使用 git pull 指令，确保从最新版本开始开发</p><p><strong>在windows上模拟开发者B：</strong></p><p><img src="'+ua+'" alt="在这里插入图片描述" loading="lazy"></p><h3 id="_3-在分支上开发" tabindex="-1">3.在分支上开发 <a class="header-anchor" href="#_3-在分支上开发" aria-label="Permalink to &quot;3.在分支上开发&quot;">​</a></h3><h4 id="开发者a" tabindex="-1"><strong>开发者A:</strong> <a class="header-anchor" href="#开发者a" aria-label="Permalink to &quot;**开发者A:**&quot;">​</a></h4><p>1、<strong>在本地创建 feature 分支，并与远端的 origin/feature 分支建立连接</strong></p><p><img src="'+Fa+'" alt="在这里插入图片描述" loading="lazy"></p><ul><li>git checkout -b featureorigin/feature 指令创建一个 feature 分支并切换到 feature 分支上，并建立远端 feature分支的追踪关系</li><li>git branch -a 指令用于显示本地和远端的所有分支</li><li>git branch -vv 指令显示本地分支与远端分支的追踪关系。可以看到此时本地的 feature 分支已经与远端的 origin/feature 分支建立了连接</li></ul><p>2、<strong>在 feature 分支上完成开发，并提交到远端的 origin/feature 分支上</strong></p><h4 id="开发者b" tabindex="-1">开发者B: <a class="header-anchor" href="#开发者b" aria-label="Permalink to &quot;开发者B:&quot;">​</a></h4><p>1、在本地创建 feature 分支，并与远端的 origin/feature 分支建立连接</p><p><img src="'+ba+'" alt="在这里插入图片描述" loading="lazy"></p><p>2、当我们尝试push到远端仓库时发生了冲突，原因是远端仓库的版本比我们当前的版本高（因为开发者A完成了push操作），我们首先需要 pull 远端仓库的分支内容，解决完冲突后才能再次 add + commit + push 📌[建议]: 在开发前首先使用 git pull 指令，确保从最新版本开始开发</p><p>3、因为我们已经建立了本地 feature 分支与远端 feature 分支的链接，所以可以直接使用 git pull 指令拉取</p><p><img src="'+ya+'" alt="在这里插入图片描述" loading="lazy"></p><p>4、手动解决冲突，从当前版本和远程仓库中的版本选择一个</p><p><img src="'+_a+'" alt="在这里插入图片描述" loading="lazy"></p><p><img src="'+fa+'" alt="在这里插入图片描述" loading="lazy"></p><p>5、重新 add + commit + push。此时我们就可以顺利推送到远程仓库了</p><h3 id="_4-分支合并" tabindex="-1">4.分支合并 <a class="header-anchor" href="#_4-分支合并" aria-label="Permalink to &quot;4.分支合并&quot;">​</a></h3><p>合并分支也有两种方式：</p><ul><li><p>提交 pull request，通过代码审验后合并到 master 分支</p></li><li><p>在本地 master 分支上合并后再 push 到远端的 master 分支</p></li></ul><p>事先声明，方法一是更被推荐的。出于教学的考虑，在单分支的版本中，先带大家用用方法二。</p><p>1、前面提到，我们要保证主分支的稳定性，因此我们不能直接将 feature 分支合并到 master 分支上，因为在解决合并冲突的过程中，我们就有可能在无意中改出了更大的 BUG。正确的做法是先将 master 分支合并到 feature 分支上，解决冲突后并且确认没有 bug 后再合并到 master 分支上。先前有过master和 feature 分支的合并记录，再合并时就不会出现冲突（都是本地操作）</p><p><img src="'+Ca+'" alt="在这里插入图片描述" loading="lazy"></p><p>2、将本地的 master 分支提交到远端</p><p><img src="'+Ba+'" alt="在这里插入图片描述" loading="lazy"></p><p><img src="'+qa+'" alt="在这里插入图片描述" loading="lazy"></p><h3 id="_5-清理" tabindex="-1">5.清理 <a class="header-anchor" href="#_5-清理" aria-label="Permalink to &quot;5.清理&quot;">​</a></h3><p>完成合并后，就可以将没用的 feature 分支删除。删除分支也有两种方式：</p><ul><li>在远端和本地分别删除 feature 分支</li><li>在本地删除 feature 分支后推送到远端</li></ul><p>这里先为大家呈现第一种删除方式：</p><p>1、远端删除 feature 分支</p><p><img src="'+Ea+'" alt="在这里插入图片描述" loading="lazy"></p><p>2、本地删除 feature 分支</p><p><img src="'+xa+'" alt="在这里插入图片描述" loading="lazy"></p><p>3、此时我们使用 git branch -r 指令仍然能看到 origin/feature，此时我们需要使用 git pull --prune 指令进行修剪</p><p><img src="'+va+'" alt="在这里插入图片描述" loading="lazy"></p><h2 id="多人协作二-多分支" tabindex="-1">多人协作二：<mark>多分支</mark> <a class="header-anchor" href="#多人协作二-多分支" aria-label="Permalink to &quot;多人协作二：==多分支==&quot;">​</a></h2><p>多人在单分支上协作开发时，经常需要解决冲突的问题；而使用多分支，各个开发者在各自的分支上独立开发，只需要在最后合并分支时解决冲突即可</p><p><strong>任务</strong>：开发者A在 feature-1 分支下编写文件file1。开发者B在 feature-2 分支下编写文件file1、file2</p><h3 id="_1-创建分支" tabindex="-1">1.创建分支 <a class="header-anchor" href="#_1-创建分支" aria-label="Permalink to &quot;1.创建分支&quot;">​</a></h3><p>前面提到，创建分支的方式有两种：</p><ul><li>在远程仓库直接创建</li><li>在本地创建分支 xxx 后使用指令 git push origin xxx 在远端创建一个与本地 xxx 分支对应的 xxx 分支</li></ul><p>我们现在采用第二种方式创建分支：</p><h4 id="开发者a-1" tabindex="-1"><strong>开发者A：</strong> <a class="header-anchor" href="#开发者a-1" aria-label="Permalink to &quot;**开发者A：**&quot;">​</a></h4><p>1、在本地创建 feature-1 分支。此时在创建本地分支时，我们不能再指定与远程分支 orgin/feature-1 建立连接，因此此时远程仓库中并没有这个分支</p><p><img src="'+Pa+'" alt="在这里插入图片描述" loading="lazy"></p><p><img src="'+za+'" alt="在这里插入图片描述" loading="lazy"></p><p>2、执行 git push origin feature-1 ，Git 会将本地的 feature-1 分支推送到 origin 远程仓库中的相应分支。如果远程仓库不存在名为 feature-1 的分支，则 git 会创建之；如果存在，则将修改合并到该分支上</p><p><img src="'+Aa+'" alt="在这里插入图片描述" loading="lazy"></p><p>3、使用 git branch -vv 指令就可以发现，本地的 feature-1 分支并没有与远端的 feature-1 分支建立追踪关系。<img src="'+Da+'" alt="在这里插入图片描述" loading="lazy"></p><p>4、因此我们不能直接使用 git pull、git push 等缩写指令。解决方法 git 也已经提示我们了①使用完整的命令 ②建立远端分支与本地分支的追踪关系</p><p><img src="'+wa+'" alt="在这里插入图片描述" loading="lazy"> 5、采用方法②来解决问题</p><p><img src="'+La+'" alt="在这里插入图片描述" loading="lazy"></p><h4 id="开发者b同理" tabindex="-1">开发者B同理 <a class="header-anchor" href="#开发者b同理" aria-label="Permalink to &quot;开发者B同理&quot;">​</a></h4><p>此时远端已经多了两个分支：</p><p><img src="'+Ga+'" alt="在这里插入图片描述" loading="lazy"></p><h3 id="_2-在分支上开发" tabindex="-1">2.在分支上开发 <a class="header-anchor" href="#_2-在分支上开发" aria-label="Permalink to &quot;2.在分支上开发&quot;">​</a></h3><p>开发者A与开发者B各自在分支上完成开发，并提交到远程分支 feature-1 与 feature-2</p><h3 id="_3-pull-request" tabindex="-1">3.pull request <a class="header-anchor" href="#_3-pull-request" aria-label="Permalink to &quot;3.pull request&quot;">​</a></h3><p>我们前面提到，合并分支也有两种方式：</p><ul><li>提交 pull request，通过代码审验后合并到 master 分支</li><li>在本地 master 分支上合并后再 push 到远端的 master 分支</li></ul><p>这里我们就是采用 pull request 的方式合并分支</p><h4 id="开发者a-2" tabindex="-1">开发者A <a class="header-anchor" href="#开发者a-2" aria-label="Permalink to &quot;开发者A&quot;">​</a></h4><p>1、提交 pull request。可自动合并说明没有遇到冲突</p><p><img src="'+Ta+'" alt="在这里插入图片描述" loading="lazy"></p><p>2、仓库的管理人员完成对你的审核通过、测试通过后，就可以合并到 master 分支中。在“文件”一栏中可以看到你的修改</p><p><img src="'+Ra+'" alt="在这里插入图片描述" loading="lazy"></p><p><img src="'+Sa+'" alt="在这里插入图片描述" loading="lazy"></p><h4 id="开发者b-1" tabindex="-1">开发者B： <a class="header-anchor" href="#开发者b-1" aria-label="Permalink to &quot;开发者B：&quot;">​</a></h4><p>1、提交 pull request。不可自动合并说明遇到了冲突</p><p><img src="'+Wa+'" alt="在这里插入图片描述" loading="lazy"></p><p>2、我们不能在 master 分支上处理冲突。解决方式与之前类似，先将 master 分支合并到 feature-2 分支上，解决完冲突后再将 feature-2 分支合并到 master 分支上</p><p>3、切换到 master 分支上，首先 git pull 拉取最新版本的 master 分支代码！！</p><p><img src="'+Ia+'" alt="在这里插入图片描述" loading="lazy"></p><p>4、切换到 feature-2 分支上，合并 master 分支。遇到冲突，冲动解决冲突</p><p><img src="'+Ma+'" alt="在这里插入图片描述" loading="lazy"></p><p>5、冲突解决，并推送到远端仓库</p><p><img src="'+Va+'" alt="在这里插入图片描述" loading="lazy"></p><p>6、此时再次发起 pull request 请求就不会遇到问题了</p><p><img src="'+Na+'" alt="在这里插入图片描述" loading="lazy"></p><h3 id="_4-清理" tabindex="-1">4.清理 <a class="header-anchor" href="#_4-清理" aria-label="Permalink to &quot;4.清理&quot;">​</a></h3><p>前面提到，删除分支也有两种方式：</p><ul><li>在远端和本地各自删除 feature 分支</li><li>在本地删除 feature 分支后推送到远端</li></ul><p>现在我们演示第二种删除方式</p><p>1、删除远端分支：git push origin --delete xxx 。</p><p><img src="'+Ua+'" alt="img" loading="lazy"></p><p>2、删除本地分支：git branch -D xxx</p><p><img src="'+ja+'" alt="在这里插入图片描述" loading="lazy"></p><h1 id="🚀git常用命令汇总" tabindex="-1">🚀Git常用命令汇总 <a class="header-anchor" href="#🚀git常用命令汇总" aria-label="Permalink to &quot;🚀Git常用命令汇总&quot;">​</a></h1>',123)),s(i),a[5]||(a[5]=t('<h2 id="一、以下是-git-命令及其作用的表格整理" tabindex="-1">一、以下是 Git 命令及其作用的表格整理： <a class="header-anchor" href="#一、以下是-git-命令及其作用的表格整理" aria-label="Permalink to &quot;一、以下是 Git 命令及其作用的表格整理：&quot;">​</a></h2><table tabindex="0"><thead><tr><th><strong>命令</strong></th><th><strong>作用</strong></th></tr></thead><tbody><tr><td><code>git config --global user.name 用户名</code></td><td>设置用户签名（用户名）</td></tr><tr><td><code>git config --global user.email 邮箱</code></td><td>设置用户签名（邮箱）</td></tr><tr><td><code>git init</code></td><td>初始化本地库</td></tr><tr><td><code>git status</code></td><td>查看本地库状态</td></tr><tr><td><code>git add 文件名</code></td><td>添加指定文件到暂存区</td></tr><tr><td><code>git add .</code></td><td>将修改的所有内容添加到暂存区</td></tr><tr><td><code>git commit -m &quot;日志信息&quot;</code></td><td>提交到本地库，并附加提交信息</td></tr><tr><td><code>git reflog</code></td><td>查看历史记录（包括被删除的 commit）</td></tr><tr><td><code>git reset --hard 版本号</code></td><td>版本回退到指定 commit</td></tr><tr><td><code>git branch 分支名</code></td><td>创建新分支</td></tr><tr><td><code>git branch -v</code></td><td>查看本地分支及其最新提交信息</td></tr><tr><td><code>git branch -a</code></td><td>查看所有分支（包括本地和远程）</td></tr><tr><td><code>git branch -r</code></td><td>查看远程分支</td></tr><tr><td><code>git checkout 分支名</code></td><td>切换分支</td></tr><tr><td><code>git merge 分支名</code></td><td>把指定分支合并到当前分支</td></tr><tr><td><code>git remote -v</code></td><td>查看当前所有远程地址别名</td></tr><tr><td><code>git remote add 别名 远程地址</code></td><td>添加远程仓库并起别名</td></tr><tr><td><code>git push 别名 分支</code></td><td>推送本地分支上的内容到远程仓库</td></tr><tr><td><code>git clone 远程地址</code></td><td>克隆远程仓库到本地</td></tr><tr><td><code>git fetch 远程地址</code></td><td>下载远程仓库的最新内容，但不合并</td></tr><tr><td><code>git pull 远程库地址别名 远程分支名</code></td><td>拉取远程仓库最新内容并合并到本地</td></tr><tr><td><code>git checkout .</code></td><td>撤销未提交的代码改动（恢复工作区）</td></tr><tr><td><code>git reset HEAD~</code></td><td>回退到上一次提交（撤销最近的一次 commit）</td></tr><tr><td><code>git diff HEAD HEAD^</code></td><td>比较当前版本与上一个版本的不同</td></tr></tbody></table><h2 id="二、git-clone-和-git-pull-的区别" tabindex="-1">二、git clone 和 git pull 的区别 <a class="header-anchor" href="#二、git-clone-和-git-pull-的区别" aria-label="Permalink to &quot;二、git clone 和 git pull 的区别&quot;">​</a></h2><p>1、git clone是将整个工程复制下来所以，不需要本地是仓库（没有.git文件夹），第一次拉取项目不需要使用git init 初始化本地仓库</p><p>2、git pull需要使用git init初始化本地仓库，</p><p>3、git clone 可以直接切换远程分支，git pull需要切换到当前分支</p><p>4、git clone 可以直接指定远程分支推送，git pull需要关联远程仓库（git add origin 远程仓库地址）才能push</p><h2 id="三、git-pull-和-git-fetch的区别" tabindex="-1">三、git pull 和 git fetch的区别 <a class="header-anchor" href="#三、git-pull-和-git-fetch的区别" aria-label="Permalink to &quot;三、git pull 和 git fetch的区别&quot;">​</a></h2><p>1、git pull：从远程获取最新版本并merge到本地，会自动合并或修改当前的工作。相当于git fetch与git merge两条命令</p><p>2、<strong>git fetch ：会将数据拉取到本地仓库 ，它并不会自动合并或修改当前的工作</strong></p><p>3、在实际使用中，git fetch更安全一些，因为在merge前，我们可以查看更新情况，然后再决定是否合并</p><h1 id="🚀git-pull-和git-fetch-git-rebase区别" tabindex="-1">🚀git pull 和git <mark>fetch</mark> &amp; git <mark>rebase</mark>区别 <a class="header-anchor" href="#🚀git-pull-和git-fetch-git-rebase区别" aria-label="Permalink to &quot;🚀git pull 和git ==fetch== &amp; git ==rebase==区别&quot;">​</a></h1>',12)),s(i),a[6]||(a[6]=t('<p>使用git上传时，一般直接使用git pull来拉数据, 但老大建议使用git fetch &amp; git rebase，所以需要了解一下它们的不同</p><ul><li>git pull: 作用是将远程分支拉回本地，做了拉取和合并两件事，其中 git pull只拉取合并本地当前所在分支</li><li>git fetch：拉取当前项目的所有分支的的提交，但不合并。在实际使用中，git fetch更安全一些因为在merge前，我们可以查看更新情况，然后再决定是否合并</li><li>git rebase ：与git merge功能相似，不同的是它将节点接到主分支的末端，最后呈现出来就是一条长长的主分支，干净明了。但要注意， rebase 是会隐藏你真实的修改记录的，所以最后呈现出来的 git 历史并不能表现你的真实操作。</li></ul><h2 id="git-merge效果" tabindex="-1">git merge效果： <a class="header-anchor" href="#git-merge效果" aria-label="Permalink to &quot;git merge效果：&quot;">​</a></h2><p><img src="'+Ka+'" alt="在这里插入图片描述" loading="lazy"></p><h2 id="git-rebase效果" tabindex="-1">git rebase效果： <a class="header-anchor" href="#git-rebase效果" aria-label="Permalink to &quot;git rebase效果：&quot;">​</a></h2><p><img src="'+$a+'" alt="在这里插入图片描述" loading="lazy"></p>',6))])}const si=h(Qa,[["render",Ya]]);export{ii as __pageData,si as default};
